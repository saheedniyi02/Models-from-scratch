# -*- coding: utf-8 -*-
"""KNearestNeighborsClassification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TBLTJFiGbS8t0TWmAETk8w2JLE4ms0lC
"""

import numpy as np
import pandas as pd
from scipy.stats import mode
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

class KNNClassifier():
  def __init__(self,K):
    self.K=K

  def fit(self,train,target):
    self.train=train
    self.target=target

    #no_of_training_examples,no_features
    self.no_train,self.no_features=train.shape

  def predict(self,test):
    try:
      self.train
    except AttributeError:
      raise Exception("This model hasn't been trained yet!")

    self.test=test
    self.no_test,self.no_test_features=test.shape

    #ensuring both train and test have same number of features
    if self.no_features!=self.no_test_features:
      raise Exception("train and test must have the same number of features")

    predictions=np.zeros(self.no_test)

    for i in range(self.no_test):
      x=self.test[i]
      neighbors=np.zeros(self.K)
      neighbors=self.find_neighbors(x)

      predictions[i]=mode(neighbors)[0][0] 
    return predictions
  
  def find_neighbors(self,x):

    euclidean_distances=np.zeros(self.no_train)

    for i in range(self.no_train):
      distance=self.euclidean(x,self.train[i])
      euclidean_distances[i]=distance

    inds=euclidean_distances.argsort()
    sorted_target=self.target[inds]
    return sorted_target[:self.K]

  def euclidean(self,x_test,x_train):
    return np.sqrt(np.sum(np.square(x_test-x_train)))

"""**Train the model**"""

data=pd.read_csv("/content/diabetes.csv")

X = data.iloc[:,:-1].values
  
Y = data.iloc[:,-1:].values
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 1/3, random_state = 0 )

knn=KNNClassifier(K=3)

knn.fit(X_train,Y_train)

pred=knn.predict(X_test)

accuracy_score(pred,Y_test)

